# s2_intra_oyster_segmentation.py
#
# Description:
# This script performs Stage 2 of the oyster analysis pipeline. It is designed
# to run after s1_oyster_instance_segmentation.py.
#
# For each WSI processed in Stage 1, this script will:
# 1. Locate the original high-resolution WSI file.
# 2. Find all the individual oyster instance masks generated by SAM in Stage 1.
# 3. For each oyster mask:
#    a. Determine the best magnification level in the WSI for analysis.
#    b. Scale the low-resolution Stage 1 mask up to the resolution of the chosen WSI level.
#    c. Generate a grid of coordinates for high-resolution patches that fall within the scaled mask.
#    d. Read each patch from the WSI file on-demand to keep memory usage low.
#    e. Use SAM's AutomaticMaskGenerator to find all segmentable features within each patch.
#    f. Save the resulting sub-masks and visualization overlays for each patch.
#
# Usage:
# 1. Ensure Stage 1 has been run and its output directory is populated.
# 2. Update the configuration variables in the SCRIPT_CONFIG section.
# 3. Run the script: python s2_intra_oyster_segmentation.py

import numpy as np
import os
import cv2
import matplotlib.pyplot as plt
import torch
import tifffile
import zarr
from segment_anything import sam_model_registry, SamPredictor, SamAutomaticMaskGenerator
import logging
import time
import glob

# torch.set_default_dtype(torch.float32)

# --- SCRIPT CONFIGURATION ---
# Paths
ORIGINAL_WSI_DIR = "/Volumes/One Touch/MSX Project/TIFF/test" # Directory containing the original, high-res WSI files
STAGE1_OUTPUT_PARENT_DIR = "output_stage1_masks_logging"      # The main output directory from s1_oyster_instance_segmentation.py
SAM_CHECKPOINT_PATH = "pretrained_checkpoint/sam_vit_h_4b8939.pth"
SAM_MODEL_TYPE = "vit_h"
OUTPUT_DIR_STAGE2 = "output_stage2_intra_oyster" # Parent directory for all Stage 2 outputs

# WSI & Patching Parameters
TARGET_MAGNIFICATION = 20.0         # Desired magnification for analysis (e.g., 5.0, 10.0, 20.0)
PATCH_SIZE = 512                    # Pixel size of square patches to extract (e.g., 256, 512, 1024)
PATCH_OVERLAP = 64                  # Overlap between patches (e.g., 0 for no overlap, or a portion of patch_size)
TISSUE_IN_PATCH_THRESHOLD = 0.1     # Min percentage of tissue required in a patch to be considered valid (0.0 to 1.0)
MANUAL_WSI_OBJECTIVE_POWER = 20.0   # Example: if scanned at 20x. Set to None if available in WSI.

# This MUST match the downsample factor used to generate the low-res image in Stage 1
STAGE1_PROCESSING_DOWNSAMPLE = 32.0

# Control plotting for debugging (can slow down batch processing significantly)
ENABLE_PLOTTING = False
# Limit number of patches to process per oyster for quick testing. Set to a high number (e.g., 99999) to process all.
MAX_PATCHES_TO_PROCESS_PER_OYSTER = 10
# --- END SCRIPT CONFIGURATION ---

# --- Global Logger ---
logger = logging.getLogger(__name__)

def setup_logging_s2(log_dir):
    """
    Configures logging to console and file for Stage 2.

    :param log_dir: Directory where log files will be saved.
    """
    os.makedirs(log_dir, exist_ok=True)
    timestamp = time.strftime("%Y%m%d-%H%M%S")
    log_file_path = os.path.join(log_dir, f"stage2_processing_{timestamp}.log")

    # Remove existing handlers to avoid duplicate logs if re-running in the same session
    if logger.hasHandlers():
        logger.handlers.clear()

    logger.setLevel(logging.DEBUG)

    # Console Handler
    console_handler = logging.StreamHandler()
    console_handler.setLevel(logging.DEBUG) # Show INFO and above on console for cleaner output
    console_formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
    console_handler.setFormatter(console_formatter)
    logger.addHandler(console_handler)

    # File Handler
    file_handler = logging.FileHandler(log_file_path)
    file_handler.setLevel(logging.DEBUG) # Log DEBUG and above to file
    file_formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    file_handler.setFormatter(file_formatter)
    logger.addHandler(file_handler)

    logger.info("Stage 2 logging setup complete. Log file: %s", log_file_path)


# --- Helper Functions ---
def load_sam_automask_generator(checkpoint_path,
                                model_type,
                                points_per_side=32,
                                pred_iou_thresh=0.88,
                                stability_score_thresh=0.95,
                                min_mask_region_area=100):
    """
    Initializes and returns the SAM AutomaticMaskGenerator.

    :param checkpoint_path: Path to the SAM model checkpoint.
    :param model_type: Type of SAM model (e.g., "vit_h").
    :param points_per_side: Number of points per side for mask generation.
    :param pred_iou_thresh: Prediction IoU threshold.
    :param stability_score_thresh: Stability score threshold.
    :param min_mask_region_area: Minimum area for mask regions.

    :return: Initialized SamAutomaticMaskGenerator instance or None if failed.
    """
    device = "mps" if torch.backends.mps.is_available() else ("cuda" if torch.cuda.is_available() else "cpu")
    logger.info(f"Using SAM device for AutomaticMaskGenerator: {device}")
    try:
        logger.info("Loading SAM model for AutomaticMaskGenerator...")
        sam_model = sam_model_registry[model_type](checkpoint=checkpoint_path)
        sam_model.to(device=device)
        mask_generator = SamAutomaticMaskGenerator(
            model=sam_model,
            points_per_side=points_per_side,
            pred_iou_thresh=pred_iou_thresh,
            stability_score_thresh=stability_score_thresh,
            min_mask_region_area=min_mask_region_area
        )
        logger.info("SAM AutomaticMaskGenerator loaded successfully.")
        return mask_generator
    except FileNotFoundError:
        logger.error(f"ðŸ›‘ SAM Checkpoint not found at {checkpoint_path}.")
    except Exception as e:
        logger.error(f"ðŸ›‘ Error loading SAM model for AutomaticMaskGenerator: {e}", exc_info=True)
    return None

def load_ome_tiff_pyramid(wsi_path, manual_objective_power=None):
    """
    Loads an OME-TIFF file and extracts its pyramid structure.

    :param wsi_path: Path to the OME-TIFF file.
    :param manual_objective_power: Manual override for objective power if not found in WSI properties.
    :return: Tuple containing: (tifffile.TiffFile object, base magnification, list of level dimensions (width, height), list of downsample factors).
    """
    logger.info(f"Loading OME-TIFF with tifffile: {wsi_path}")
    try:
        tif = tifffile.TiffFile(wsi_path)  # Open the file as a Zarr store
        if not tif.is_ome:
            logger.warning("TIFF file does not appear to be an OME-TIFF according to tifffile.")

        base_magnification = float(manual_objective_power) if manual_objective_power else None
        main_series = tif.series[0]
        num_levels = len(main_series.levels)
        logger.info(f"Series 0 has {num_levels} levels.")

        level_dimensions_wh, level_downsamples = [], []
        base_width, base_height = main_series.levels[0].shape[1], main_series.levels[0].shape[0]

        for i, level in enumerate(main_series.levels):
            lvl_shape = level.shape
            level_dimensions_wh.append((lvl_shape[1], lvl_shape[0]))
            ds = base_width / lvl_shape[1] if lvl_shape[1] > 0 else 1.0
            level_downsamples.append(ds)

        logger.info(f"  Processed level dimensions (W,H): {level_dimensions_wh}")
        logger.info(f"  Calculated level downsamples: {[round(ds, 2) for ds in level_downsamples]}")
        return tif, base_magnification, level_dimensions_wh, level_downsamples
    except Exception as e:
        logger.error(f"ðŸ›‘ Error opening/processing OME-TIFF with tifffile: {e}", exc_info=True)
        return None, None, [], []

def load_stage1_instance_mask(mask_path):
    """
    Loads the instance mask from Stage 1.

    :param mask_path: Path to the instance mask image file.
    :return: Binary mask image (numpy array) or None if loading failed.
    """
    logger.info(f"Loading Stage 1 instance mask: {mask_path}")
    mask_low_res = cv2.imread(mask_path, cv2.IMREAD_GRAYSCALE)
    if mask_low_res is None:
        logger.error(f"ðŸ›‘ Instance mask {mask_path} not found or could not be loaded.")
        return None
    _, mask_low_res_binary = cv2.threshold(mask_low_res, 127, 255, cv2.THRESH_BINARY)
    logger.debug(f"Instance mask loaded, shape: {mask_low_res_binary.shape}")
    return mask_low_res_binary

def get_level_for_target_mag(base_mag, target_mag, known_downsamples):
    """
    Determines the best WSI level index and downsample factor for the target magnification.

    :param base_mag: The base magnification of the WSI.
    :param target_mag: The target magnification for analysis.
    :param known_downsamples: List of known downsample factors for the WSI levels.
    :return: Tuple containing the best level index and its downsample factor.
    """
    if not base_mag or not target_mag: return 0, known_downsamples[0]
    ideal_downsample = base_mag / target_mag
    best_level_idx = 0
    # Find the level with the highest resolution that is still at or below the target magnification
    # (i.e., its downsample is >= the ideal downsample)
    for i, ds in reversed(list(enumerate(known_downsamples))):
        if ds <= ideal_downsample:
            best_level_idx = i
            break
    return best_level_idx, known_downsamples[best_level_idx]

def show_anns(anns, ax):
    """
    Helper function to display masks from SamAutomaticMaskGenerator.

    :param anns: List of annotations (masks) to display.
    :param ax: Matplotlib axis to draw the masks on.
    """
    if not anns: return
    sorted_anns = sorted(anns, key=(lambda x: x['area']), reverse=True)
    # Create a blank RGBA image for the overlay
    overlay = np.zeros((anns[0]['segmentation'].shape[0], anns[0]['segmentation'].shape[1], 4), dtype=np.uint8)
    for ann in sorted_anns:
        m = ann['segmentation']
        color_mask = np.random.choice(range(256), size=3)
        overlay[m, 0] = color_mask[0]  # R
        overlay[m, 1] = color_mask[1]  # G
        overlay[m, 2] = color_mask[2]  # B
        overlay[m, 3] = 150  # Alpha (transparency)
    ax.imshow(overlay.astype('uint8'))

def find_wsi_file_by_basename(wsi_dir, base_name):
    """
    Searches for a WSI file in the specified directory by its base name.

    :param wsi_dir: Directory where WSI files are stored.
    :param base_name: Base name of the WSI file to search for (without extension).
    :return: Full path to the WSI file if found, otherwise None.
    """
    for ext in (".tif", ".tiff", ".vsi", ".svs"):  # Add other WSI extensions if needed
        potential_file = os.path.join(wsi_dir, base_name + ext)
        if os.path.exists(potential_file):
            return potential_file
        # Handle cases where s1 might have altered the name slightly, like replacing " - "
    for f in os.listdir(wsi_dir):
        if os.path.splitext(f)[0] == base_name:
            return os.path.join(wsi_dir, f)
    return None

# --- Main Processing Function for Single Oyster ---
def process_single_oyster_instance(wsi_file_path, instance_mask_path, sam_mask_generator, output_dir_s2_parent):
    """
    Processes a single oyster instance by:
    1. Loading the WSI and its properties.
    2. Loading the specific oyster instance mask.
    3. Determining the best patching level and scaling the mask.
    4. Loading the entire image plane for patching.
    5. Generating patch coordinates and extracting valid patches.
    6. Processing valid patches with SAM AutomaticMaskGenerator.
    7. Saving the resulting sub-masks and visualizations.
    This function is designed to be called for each oyster instance found in Stage 1.

    :param wsi_file_path: The path to the original WSI file.
    :param instance_mask_path: The path to the specific oyster instance mask generated in Stage 1.
    :param sam_mask_generator: An instance of SamAutomaticMaskGenerator for generating masks.
    :param output_dir_s2_parent: The parent directory where Stage 2 outputs will be saved.
    """
    wsi_base_name = os.path.splitext(os.path.basename(wsi_file_path))[0]
    mask_base_name = os.path.splitext(os.path.basename(instance_mask_path))[0]

    # Create a unique output directory for this specific oyster mask
    instance_output_dir = os.path.join(output_dir_s2_parent, wsi_base_name, mask_base_name)
    os.makedirs(instance_output_dir, exist_ok=True)
    logger.info(f"Output for this instance will be saved in: {instance_output_dir}")

    # 1. Load WSI and its properties
    wsi_file_obj, base_wsi_mag, wsi_level_dims, wsi_level_ds = load_ome_tiff_pyramid(
        wsi_file_path, MANUAL_WSI_OBJECTIVE_POWER
    )
    if not wsi_file_obj:
        logger.error(f"ðŸ›‘ WSI could not be loaded for {wsi_file_path}. Aborting this instance.")
        return

    # 2. Load the specific oyster instance mask
    oyster_mask_s1_res = load_stage1_instance_mask(instance_mask_path)
    if oyster_mask_s1_res is None:
        wsi_file_obj.close()
        return

    # 3. Determine best patching level and scale the mask
    best_level, actual_ds = get_level_for_target_mag(base_wsi_mag, TARGET_MAGNIFICATION, wsi_level_ds)
    effective_mag = base_wsi_mag / actual_ds
    dims_of_patch_level = wsi_level_dims[best_level]

    logger.info(
        f"Best WSI level for patching: {best_level} (Downsample: {actual_ds:.2f}x, Effective Mag: {effective_mag:.2f}x)")

    # 4. Scale the low-res Stage 1 mask to the resolution of the chosen WSI level
    logger.debug(
        f"Scaling Stage 1 mask to Level {best_level} resolution ({dims_of_patch_level[0]}x{dims_of_patch_level[1]})")
    scaled_mask = cv2.resize(oyster_mask_s1_res, dims_of_patch_level, interpolation=cv2.INTER_NEAREST)
    _, scaled_mask_binary = cv2.threshold(scaled_mask, 127, 255, cv2.THRESH_BINARY)

    # # 4. Load the entire image plane for patching to avoid repeated reads
    # try:
    #     logger.info(f"Loading entire image plane for WSI Level {best_level}...")
    #     image_plane = wsi_file_obj.series[0].levels[best_level].asarray()
    #     if image_plane.ndim == 3 and image_plane.shape[2] == 4:
    #         image_plane = cv2.cvtColor(image_plane, cv2.COLOR_RGBA2RGB)
    #     elif image_plane.ndim != 3 or image_plane.shape[2] != 3:
    #         image_plane = cv2.cvtColor(image_plane, cv2.COLOR_GRAY2RGB)  # Ensure 3 channels for SAM
    #     logger.info(f"Successfully loaded image plane for patching, shape: {image_plane.shape}")
    # except Exception as e:
    #     logger.error(f"ðŸ›‘ Error loading image plane for level {best_level}: {e}", exc_info=True)
    #     wsi_file_obj.close()
    #     return

    # 5. Generate patch coordinates and extract valid patches
    logger.info("Generating and validating patch coordinates...")
    patch_coordinates = []
    level_h, level_w = dims_of_patch_level[1], dims_of_patch_level[0]
    step_size = PATCH_SIZE - PATCH_OVERLAP

    for y in range(0, level_h - PATCH_SIZE + 1, step_size):
        for x in range(0, level_w - PATCH_SIZE + 1, step_size):
            mask_patch = scaled_mask_binary[y:y + PATCH_SIZE, x:x + PATCH_SIZE]
            if cv2.countNonZero(mask_patch) > (PATCH_SIZE * PATCH_SIZE * TISSUE_IN_PATCH_THRESHOLD):
                patch_coordinates.append((x, y))

    logger.info(f"Found {len(patch_coordinates)} valid patches to process.")

    # 6. Process valid patches with SAM AutomaticMaskGenerator
    num_to_process = min(MAX_PATCHES_TO_PROCESS_PER_OYSTER, len(patch_coordinates))
    logger.info(f"Processing first {num_to_process} patches with SAM...")

    # Create a Zarr array wrapper for the chosen level. This does NOT load the image into memory.
    try:
        # Create a Zarr array wrapper for the chosen level. This does NOT load the image into memory.
        zarr_store = wsi_file_obj.series[0].aszarr()
        zarr_group = zarr.open(zarr_store, mode='r')
        zarr_array = zarr_group[best_level] # Access the specific level
        logger.debug(f"Created Zarr array for Level {best_level}. Array shape: {zarr_array}")
    except Exception as e:
        logger.error(f"ðŸ›‘ Could not create Zarr wrapper for Level {best_level}: {e}", exc_info=True)
        wsi_file_obj.close()
        return

    for i, (x, y) in enumerate(patch_coordinates[:num_to_process]):
        patch_prefix = f"patch_lvl{best_level}_x{x}_y{y}"
        logger.debug(f"  Processing patch {i + 1}/{num_to_process}: {patch_prefix}")

        try:
            # Use NumPy slicing on the Zarr array. This reads only the specified region from the file.
            patch_image_raw = zarr_array[y:y + PATCH_SIZE, x:x + PATCH_SIZE] # <<< FIX: SLICE THE CORRECT ARRAY

            # Ensure patch is 3-channel RGB for SAM
            if patch_image_raw.ndim == 3 and patch_image_raw.shape[2] == 4:
                patch_image_rgb = cv2.cvtColor(patch_image_raw, cv2.COLOR_RGBA2RGB)
            elif patch_image_raw.ndim == 2 or patch_image_raw.shape[2] == 1:
                patch_image_rgb = cv2.cvtColor(patch_image_raw, cv2.COLOR_GRAY2RGB)
            else:
                patch_image_rgb = patch_image_raw

            generated_masks = sam_mask_generator.generate(patch_image_rgb)
            logger.debug(f"    SAM generated {len(generated_masks)} masks for this patch.")

            if generated_masks:
                patch_output_dir = os.path.join(instance_output_dir, patch_prefix)
                os.makedirs(patch_output_dir, exist_ok=True)

                for j, ann in enumerate(generated_masks):
                    mask_filename = f"mask_{j:03d}_area_{ann['area']}_iou_{ann['predicted_iou']:.2f}.png"
                    cv2.imwrite(os.path.join(patch_output_dir, mask_filename),
                                ann['segmentation'].astype(np.uint8) * 255)

                fig, ax = plt.subplots(figsize=(8, 8))
                ax.imshow(patch_image_rgb)
                show_anns(generated_masks, ax)  # Use the fixed show_anns function
                ax.set_title(f"SAM Auto-Masks for {patch_prefix}")
                ax.axis('off')

                # FIX: Save the plot to disk. Only show interactively if ENABLE_PLOTTING is True
                plt.savefig(os.path.join(patch_output_dir, f"{patch_prefix}_overlay.png"))
                if ENABLE_PLOTTING:
                    plt.show()  # This will pause the script and show the plot window
                plt.close(fig)  # Free memory
        except Exception as e:
            logger.error(f"ðŸ›‘ Error during processing for patch {patch_prefix}: {e}", exc_info=True)

    logger.info(f"\t\t\t--- Finished processing instance: {mask_base_name} ---")
    wsi_file_obj.close()
    logger.debug("Closed WSI file object.")

# --- Main Execution ---
if __name__ == "__main__":
    setup_logging_s2(OUTPUT_DIR_STAGE2)
    logger.info("\t\t\t--- Stage 2: Intra-Oyster Region Segmentation (Batch Processing) ---")

    # Initialize SAM once for the whole batch
    shared_sam_mask_generator = load_sam_automask_generator(SAM_CHECKPOINT_PATH, SAM_MODEL_TYPE)
    if not shared_sam_mask_generator:
        logger.critical("ðŸ›‘ SAM AutomaticMaskGenerator could not be initialized. Exiting.")
        exit(1)

    # Find all processed WSI directories from Stage 1
    if not os.path.isdir(STAGE1_OUTPUT_PARENT_DIR):
        logger.critical(f"ðŸ›‘ Stage 1 output directory not found at: {STAGE1_OUTPUT_PARENT_DIR}")
        exit(1)

    s1_processed_dirs = [d for d in os.listdir(STAGE1_OUTPUT_PARENT_DIR) if os.path.isdir(os.path.join(STAGE1_OUTPUT_PARENT_DIR, d))]
    logger.info(f"Found {len(s1_processed_dirs)} processed WSI directories from Stage 1.")

    for s1_dir_name in s1_processed_dirs:
        logger.info(f"\t\t>>> Checking Stage 1 output directory: {s1_dir_name}")

        # Find the corresponding original WSI file
        original_wsi_path = find_wsi_file_by_basename(ORIGINAL_WSI_DIR, s1_dir_name)
        if not original_wsi_path:
            logger.warning(f"  - Could not find matching original WSI for '{s1_dir_name}' in '{ORIGINAL_WSI_DIR}'. Skipping.")
            continue
        logger.info(f"  + Found corresponding WSI: {original_wsi_path}")

        # Find all SAM-generated instance masks for this WSI
        masks_dir = os.path.join(STAGE1_OUTPUT_PARENT_DIR, s1_dir_name, "sam_generated_masks")
        if not os.path.isdir(masks_dir):
            logger.info(f"  - No 'sam_generated_masks' sub-folder found for {s1_dir_name}. Skipping.")
            continue

        oyster_mask_files = glob.glob(os.path.join(masks_dir, "*_sam_mask_*.png"))
        logger.info(f"  + Found {len(oyster_mask_files)} oyster instance masks to process.")

        # Process each oyster mask individually
        for mask_path in oyster_mask_files:
            process_single_oyster_instance(
                original_wsi_path,
                mask_path,
                shared_sam_mask_generator,
                OUTPUT_DIR_STAGE2
            )

    logger.info("\n--- Fin ---")
